# Спринт 3

## Задание 1
Описание исходной системы: 
* Система позволяет сохранять настройки пользователей (наличие отопления, желаемая температура)
* Система собирает информацию с датчиков и сохраняет текущую температуру для отображения пользователю и поддержания желаемой температуры

Минусы исходной системы:
* Все данные система хранит в одной БД несмотря на разный профиль нагрузки и саму нагрузку 
* То же самое с API (приходится горизонтально масштабировать один монолит в соответствии с нагрузкой на самый нагруженный сценарий) 
* Сложно развивать разный функционал: приходится задевать и вносить изменения в смежном, есть риск сломать всю систему 
* Каждый раз необходимо развертывать весь монолит

Плюсы исходной системы:
* Быстрая и дешевая реализация MVP, после которой уже можно пересмотреть ее арх-ру и перевести на микросервисы

Диаграммы в проекте начинаются на префикс SmartHome_

Были выделены следующие контейнеры: 
* контейнеры взаимодействия с пользователем (содержат бизнес логику которая ближе всего к пользователю):
  * **API Gateway** - предоставляет собой входную точку в систему для трафика
* контейнеры работы с текущими настройками/состоянием девайсов для пользователей
  * **SettingsService** - сервис настроек девайса. Управляет и возвращает настройки по термпературе / наличию отопления. В случае изменения настроек пользователем, отправляет события, чтобы другой микросервис мог подписаться и установить эти настройки в самом девайсе
  * **SettingsDatabase** - БД для SettingsService
  * **CurrentStateService** - сервис текущего состояния девайсов. Подписывается на события измененения состояния девайсов и сохраняет их в своей БД. Предоставляет поьлзователю информацию о текущем состоянии/истории
  * **CurrentStateDatabase** - БД для CurrentStateService
* контейнеры взаимодействия с девайсами 
  * **DevicesApiIntegration** - фасад для интеграции с API девайсов 
  * **DevicesStateCollector** - воркер, собирающий данные с девайсов и отправляющий события с информацией с датчиков, на которые подписывается **CurrentStateService**
  * **DevicesStateApplier** - сервис изменения настроек девайсов. Слушает события от **SettingsService**
* контейнеры управления девайсами
  * **UserDevicesService** - сервис управления девайсами пользователя (линковка и отлинковка девайсов)
  * **UserDevicesDatabase** - БД для UserDevicesService

Диаграммы компонентов были нарисованы для: SettingsService, CurrentStateService, DeviceStateCollector. 

В качестве диаграмм кода были нарисованы диаграммы классов для SettingsService, CurrentStateService.

ER диаграмма была нарисована для системы в целом, потому что из-за деления на микросервисы получилось почти что 1 сущность - 1 микросервис, и если рисовать ER диаграмму для одного конкретного сервиса, то на ней было бы 1-2 сущности

Документация Open API была описана для SettingsService, Async API - для SettingsService и DeviceStateApplier

## Задание 2
Микросервисы были реализованы в соответствии с текстом задания (описанные в задании ручки), а не в соответствии со схемами из предыдущего задания, потому что было непонятно - надо следовать заданию или тому что получилось на прошлом этапе 
Микросервисы реализованы, но в случае сервиса управления девайсами не реализована отправка сообщения в Kafka при установке настроекк (только сохраняются в БД). 
Микросервисы разворачиваются через docker-compose

## Ответы на вопросы с ревью 
> Увидел контейнерную диаграмму решения TOBE, но взаимодействия в ней описаны только для работы с датчиками температуры. В будущем решении у нас будет множество разных датчиков

Не понимаю, что изменится при добавлении других датчиков. Во взаимодействии с датчиками участвуют 3 сервиса: 
* **DevicesApiIntegration** - просто предоставляет прослойку между нашей системой и внешним API. Может ходить в любые датчики (не только температуры)
* **DevicesStateCollector** - тоже просто воркер, который для батча датчиков постоянно запрашивает текущее состояние (через **DevicesApiIntegration**), которое может быть как температурой так и не температурой (не важно) 
* **DevicesStateApplier** - консюмер сообщений об изменениях настроек для датчиков пользователем - тоже может принимать любые сообщения, не только температуру

Аналогично с сервисами которые хранят настройки/текущую температуру - в качестве температуры там может быть просто "показатель датчика", контейнерную диаграму это не меняет никак. Я могу поменять в потоках данных везде слово температура на "measure", но суть не изменится 


> Не увидел сервиса по работе с пользователями
> Непонятно разделение SettingsService и UserDevicesService. Что каждый из них делает? Почему не объединить?

Вообще у меня как раз в качестве сервиса работы с пользователями скорее выступает сервис UserDevicesService, он отвечает за привязку пользователей к домам/девайсам, то есть это управление аккаунтом. А вот SettingsService - это управление конкретным девайсом, и одним девайсом могут управлять несколько человек, имеющих к нему доступ

Добавила счас еще отдельно именно сервис юзеров (для их регистрации/авторизации и хранения учеток). UserDevicesService - он для линковки юзеров и девайсов + более подробная информация о девайсах которая не нужна нам в сервисах измерений, такая как гео локация девайса, название и тд.

> DevicesApiIntegration является очень слабым местом при учете того, что у нас 100 000 устройств и возможно они отправляют данные раз в секунду

В DevicesApiIntegration нет никаких входящих запросов снаружи системы, в него поступает трафик только от DevicesStateCollector (батчи id датчиков для получения информации о температуре) и DevicesStateApplier (для установки настроек в датчики). И конечно у нас несколько инстансов DevicesApiIntegration. Я не понимаю, в чем тут может быть проблема 

> Согласно структуре хранилища, система работает только с температурой. Что неверно. У нас много разных девайсов
> OpenAPI и AsyncAPI реализованы только для температуры. Они должны быть более универсальны

Переделала, насколько я понимаю просто там может быть любьое измерение вместо температуры 